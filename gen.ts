import path from "path";

type ImageEntry = {
	id: string;
	path: string;
	uv?: [number, number, number, number];
};
type FontEntry = { id: string; path: string };
type IconEntry = { id: string; path: string; fill?: number; stroke?: number };
type Spec = { images?: ImageEntry[]; fonts?: FontEntry[]; icons?: IconEntry[] };

const [, , inPath, outPath] = process.argv;
if (!inPath || !outPath) {
	console.error("Usage: bun generate-resources.ts <resources.json> <out.h>");
	process.exit(1);
}

const spec: Spec = await Bun.file(inPath).json();
const jsonDir = path.dirname(path.resolve(inPath));
const outDir = path.dirname(path.resolve(outPath));

const images = Array.isArray(spec.images) ? spec.images : [];
const fonts = Array.isArray(spec.fonts) ? spec.fonts : [];
const icons = Array.isArray(spec.icons) ? spec.icons : [];

function posixRel(fromDir: string, absFile: string): string {
	const rel = path.relative(fromDir, absFile);
	return rel.split(path.sep).join("/");
}
function resolveForEmbed(relFromJson: string) {
	const abs = path.resolve(jsonDir, relFromJson);
	return {
		abs,
		embedRelToOut: posixRel(outDir, abs),
		baseName: path.basename(abs),
	};
}
function blobSymFromPath(embedRelToOut: string): string {
	const base = path.basename(embedRelToOut).toLowerCase();
	const sym = base.replace(/[^a-z0-9]+/gi, "_").replace(/^_+|_+$/g, "");
	return `res_${sym}`;
}
function uvSymFromId(id: string): string {
	return `uv_${id}`;
}
function formatHexColor(color: number | undefined): string {
	if (color === undefined) return "0x808080FF";

	return `0x${color.toString(16).toUpperCase().padStart(8, "0")}`;
}

function genHeader(): string {
	const out: string[] = [];

	out.push(
		"/* Auto-generated by generate-resources.ts â€” do not edit by hand. */",
		"#ifndef RESOURCES_H",
		"#define RESOURCES_H",
		"",
		"#include <stddef.h> /* size_t */",
		"#include <stdint.h> /* uint32_t */",
		"",
		"/* ===== Resource kinds (tag) ===== */",
		"typedef enum {",
		"    RES_KIND_IMAGE = 1,",
		"    RES_KIND_FONT  = 2,",
		"    RES_KIND_ICON  = 3,",
		"} ResourceKind;",
		"",
		"/* UV payload for images (used via pointer, may be NULL) */",
		"typedef struct ResourceUV {",
		"    float u0, v0, u1, v1;",
		"} ResourceUV;",
		"",
		"/* Tagged union for all embedded resources */",
		"typedef struct EmbeddedBlob {",
		"    const unsigned char *data;",
		"    size_t size;",
		"    const char *name;",
		"    ResourceKind kind;",
		"    union {",
		"        struct {",
		"            const ResourceUV *uv; /* NULL if not provided */",
		"        } image;",
		"        struct {",
		"            int _unused; /* room for future font-specific metadata */",
		"        } font;",
		"        struct {",
		"            uint32_t fill;   /* RGBA color in 0xRRGGBBAA format */",
		"            uint32_t stroke; /* RGBA color in 0xRRGGBBAA format */",
		"        } icon;",
		"    } as;",
		"} EmbeddedBlob;",
		"",
	);

	out.push("/* ===== Per-kind IDs ===== */");
	if (images.length === 0) {
		out.push("typedef enum { RES_IMG_COUNT = 0 } ResourceImageId;", "");
	} else {
		out.push("typedef enum {");
		for (const i of images) out.push(`    ${i.id},`);
		out.push("    RES_IMG_COUNT", "} ResourceImageId;", "");
	}
	if (fonts.length === 0) {
		out.push("typedef enum { RES_FONT_COUNT = 0 } ResourceFontId;", "");
	} else {
		out.push("typedef enum {");
		for (const f of fonts) out.push(`    ${f.id},`);
		out.push("    RES_FONT_COUNT", "} ResourceFontId;", "");
	}
	if (icons.length === 0) {
		out.push("typedef enum { RES_ICON_COUNT = 0 } ResourceIconId;", "");
	} else {
		out.push("typedef enum {");
		for (const i of icons) out.push(`    ${i.id},`);
		out.push("    RES_ICON_COUNT", "} ResourceIconId;", "");
	}

	out.push("/* ===== Unified index & iteration macros ===== */");
	out.push(
		`#define RES_COUNT        (RES_IMG_COUNT + RES_FONT_COUNT + RES_ICON_COUNT)`,
	);
	out.push(`#define RES_FIRST_IMAGE  0`);
	out.push(`#define RES_LAST_IMAGE   (RES_FIRST_IMAGE + RES_IMG_COUNT - 1)`);
	out.push(`#define RES_FIRST_FONT   (RES_LAST_IMAGE + 1)`);
	out.push(`#define RES_LAST_FONT    (RES_FIRST_FONT + RES_FONT_COUNT - 1)`);
	out.push(`#define RES_FIRST_ICON   (RES_LAST_FONT + 1)`);
	out.push(`#define RES_LAST_ICON    (RES_FIRST_ICON + RES_ICON_COUNT - 1)`);
	out.push(`#define RES_INDEX_IMAGE(id) (RES_FIRST_IMAGE + (id))`);
	out.push(`#define RES_INDEX_FONT(id)  (RES_FIRST_FONT  + (id))`);
	out.push(`#define RES_INDEX_ICON(id)  (RES_FIRST_ICON  + (id))`);
	if (images.length > 0) {
		out.push(
			`#define RES_FOR_EACH_IMAGE(idvar) \\\n    for (int idvar = 0; idvar < RES_IMG_COUNT; ++idvar)`,
		);
	} else {
		out.push(`#define RES_FOR_EACH_IMAGE(idvar) /* no images */`);
	}
	if (fonts.length > 0) {
		out.push(
			`#define RES_FOR_EACH_FONT(idvar)  \\\n    for (int idvar = 0; idvar < RES_FONT_COUNT; ++idvar)`,
		);
	} else {
		out.push(`#define RES_FOR_EACH_FONT(idvar)  /* no fonts */`);
	}
	if (icons.length > 0) {
		out.push(
			`#define RES_FOR_EACH_ICON(idvar)  \\\n    for (int idvar = 0; idvar < RES_ICON_COUNT; ++idvar)`,
		);
	} else {
		out.push(`#define RES_FOR_EACH_ICON(idvar)  /* no icons */`);
	}
	out.push("");

	if (images.some((i) => Array.isArray(i.uv) && i.uv.length === 4)) {
		for (const i of images) {
			if (Array.isArray(i.uv) && i.uv.length === 4) {
				const [u0, v0, u1, v1] = i.uv;
				out.push(
					`static const ResourceUV ${uvSymFromId(i.id)} = { ${u0}, ${v0}, ${u1}, ${v1} };`,
				);
			}
		}
		out.push("");
	}

	for (const i of images) {
		const { embedRelToOut } = resolveForEmbed(i.path);
		const sym = blobSymFromPath(embedRelToOut);
		out.push(
			`static const unsigned char ${sym}[] = {`,
			`    #embed "${embedRelToOut}"`,
			"};",
		);
	}
	for (const f of fonts) {
		const { embedRelToOut } = resolveForEmbed(f.path);
		const sym = blobSymFromPath(embedRelToOut);
		out.push(
			`static const unsigned char ${sym}[] = {`,
			`    #embed "${embedRelToOut}"`,
			"};",
		);
	}
	for (const i of icons) {
		const { embedRelToOut } = resolveForEmbed(i.path);
		const sym = blobSymFromPath(embedRelToOut);
		out.push(
			`static const unsigned char ${sym}[] = {`,
			`    #embed "${embedRelToOut}"`,
			`    , 0 /* null terminator for SVG strings */`,
			"};",
		);
	}
	out.push("");

	out.push("static const EmbeddedBlob g_embedded_resources[RES_COUNT] = {");

	for (const i of images) {
		const { embedRelToOut, baseName } = resolveForEmbed(i.path);
		const sym = blobSymFromPath(embedRelToOut);
		const uvPtr =
			Array.isArray(i.uv) && i.uv.length === 4
				? `&${uvSymFromId(i.id)}`
				: "NULL";
		out.push(
			`    [RES_INDEX_IMAGE(${i.id})] = { ${sym}, sizeof(${sym}), "${baseName}", RES_KIND_IMAGE, { .image = { ${uvPtr} } } },`,
		);
	}

	for (const f of fonts) {
		const { embedRelToOut, baseName } = resolveForEmbed(f.path);
		const sym = blobSymFromPath(embedRelToOut);
		out.push(
			`    [RES_INDEX_FONT(${f.id})] = { ${sym}, sizeof(${sym}), "${baseName}", RES_KIND_FONT,  { .font  = { 0 } } },`,
		);
	}

	for (const i of icons) {
		const { embedRelToOut, baseName } = resolveForEmbed(i.path);
		const sym = blobSymFromPath(embedRelToOut);
		const fill = formatHexColor(i.fill);
		const stroke = formatHexColor(i.stroke);
		out.push(
			`    [RES_INDEX_ICON(${i.id})] = { ${sym}, sizeof(${sym}), "${baseName}", RES_KIND_ICON,  { .icon  = { ${fill}, ${stroke} } } },`,
		);
	}
	out.push("};", "");

	out.push("/* ===== Quick access macros ===== */");
	out.push("#define RES_GET(index)           (&g_embedded_resources[index])");
	out.push(
		"#define RES_GET_IMAGE(id)        (&g_embedded_resources[RES_INDEX_IMAGE(id)])",
	);
	out.push(
		"#define RES_GET_FONT(id)         (&g_embedded_resources[RES_INDEX_FONT(id)])",
	);
	out.push(
		"#define RES_GET_ICON(id)         (&g_embedded_resources[RES_INDEX_ICON(id)])",
	);
	out.push(
		"#define RES_GET_IMAGE_DATA(id)   (g_embedded_resources[RES_INDEX_IMAGE(id)].data)",
	);
	out.push(
		"#define RES_GET_IMAGE_SIZE(id)   (g_embedded_resources[RES_INDEX_IMAGE(id)].size)",
	);
	out.push(
		"#define RES_GET_IMAGE_UV(id)     (g_embedded_resources[RES_INDEX_IMAGE(id)].as.image.uv)",
	);
	out.push(
		"#define RES_GET_FONT_DATA(id)    (g_embedded_resources[RES_INDEX_FONT(id)].data)",
	);
	out.push(
		"#define RES_GET_FONT_SIZE(id)    (g_embedded_resources[RES_INDEX_FONT(id)].size)",
	);
	out.push(
		"#define RES_GET_ICON_DATA(id)    (g_embedded_resources[RES_INDEX_ICON(id)].data)",
	);
	out.push(
		"#define RES_GET_ICON_SIZE(id)    (g_embedded_resources[RES_INDEX_ICON(id)].size)",
	);
	out.push(
		"#define RES_GET_ICON_FILL(id)    (g_embedded_resources[RES_INDEX_ICON(id)].as.icon.fill)",
	);
	out.push(
		"#define RES_GET_ICON_STROKE(id)  (g_embedded_resources[RES_INDEX_ICON(id)].as.icon.stroke)",
	);
	out.push("");

	out.push("#endif /* RESOURCES_H */", "");
	return out.join("\n");
}

await Bun.write(outPath, genHeader());
console.log(`Generated ${outPath} from ${inPath}`);
